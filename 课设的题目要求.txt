用动态规划方法计算编辑距离并完成自动编辑 
（1）问题描述 
对于任意两个字符串 s1，s2 的差别，可以通过其编辑距离来度量。编辑距离就是指让 s1 变成 s2 或将 s2 变成 s1 所需要编辑操作的最小次数。此处定义 3个基本编辑操作：把某个字符 ch1 变成 ch2；删除某个字符；插入某个字符。如对于 s1=12433 和 s2=1233，则可以通过在 s1 中间删除 4 得到 1233 来与 s2 一致，所以 d（s1，s2）=1（进行了一次删除操作），也即 s1，s2 的编辑距离为 1。可以依靠编辑距离的性质来帮助完成编辑距离的计算。当计算两个字符串s1+ch1,s2+ch2 的编辑距离有这样的性质:
①d（s1，“”）=d（“”， s1）=|s1|； 
d（“ch1”，”ch2”）=ch1==ch2？0:1。
②d（s1+ch1，s2+ch2）=min（d（s1,s2）+ch1==ch2？0:1，
d（s1+ch1,s2）+1，d（s1,s2+ch2）+1）。 
具有第二个性质的原因是在 s1+ch1 和 s2+ch2 相互转化时可能的操作有：①把 ch1 变成 ch2，此时 d（s1+ch1，s2+ch2）=d（s1,s2）+ch1==ch2？0:1。②s1+ch1删除 ch1 和 s2+ch2 转化，此时 d（s1+ch1，s2+ch2）=（1+d（s1，s2+ch2））。③s2+ch2 删除 ch2 和 s1+ch1 转化，此时 d（s1+ch1，s2+ch2） = （1+d（s1+ch1，s2））。④s2+ch2 后添加 ch1 和 s1+ch1 转化，实际上等同于 s2+ch2 和 s1 转化，此时 d（s1+ch1，s2+ch2）=（1+d（s1，s2+ch2））。⑤s1+ch1 后添加 ch2 和 s2+ch2 转化，实际上等同于 s1+ch1 和 s2 转化，此时 d（s1+ch1，s2+ch2）=（1+d（s2，s1+ch1））。有了这样的性质，可以发现在计算 d（m，n）时用到了 d（m-1，n），d（m-1，n-1），d（m，n-1）等，也就是说明该问题具有重叠子问题结构（原问题的递归算法反复的求解同样的子问题，而不产生新的子问题），再由性质②表明的最优子结构（一个问题的最优解包含了子问题的最优解），符合动态规划算法基本要素。因此可以使用动态规划算法来求解该问题。 
由此可以得到这样的动态规划算法：设定数组 M[|s1|，|s2|]保存子问题结果，其中 M[i,j]表示子串 s1（0->i）与 s2（0->j）的编辑距离。产生字符之间的编辑距离，E[|s1|,|s2|]，其中 E[i,j]=s[i]=s[j]?0:1。初始化 M 矩阵，M[0,0]=0；M[s1i，0]=|s1i|；M[0,s2j]=|s2j|。 
根据性质②计算出矩阵 M，得到编辑距离：M[i，j]=min（m[i-1,j-1]+E[i,j]，m[i,j-1]+1，m[i-1,j]）。 
另外，编辑距离也会随着编辑操作而有所变化，如也可以这样来定义编辑：给定两个字符串 x[1..m]和 y[1..n]，编辑的目标是找到一系列的编辑操应用于 x使它变为 y。用一个中间变量 z 来保存中间结果，算法开始的时候 z 是一个空字符串，算法结束的时候对所有 j=1,2,...,n 有 zj=yj。用变量 i 标记当前正被处理的字符在 x 中的下标，用 j 标记 z 的当前下标，我们的编辑操作就是作用于 i,j 和 z上面的。开始时有 i=j=1，要求是在转换过程中一一检查 x 中的每一个字符，也  就是说在转换结束的时候必须有 i=m+1。 
现定义六种编辑操作：①拷贝：把一个字符从 x 拷贝到 z，即令 zj=xi，之后令 i=i+1,j=j+1。这个操作检查了 xi。②替换：将 x 中的一个字符替换为另外一个，即令 zj=c，之后令 i=i+1,j=j+1。这个操作检查了 xi。③删除：从 x 中删除一个字符，即令 i=i+1，j 不变。这个操作检查了 xi。④插入：向 z 中插入一个字符，即令 zj=c，之后令 j=j+1，i 不变。这个操作没有检查 x 中的任何字符。⑤换位：把x中将要处理的下两个字符拷贝到x中，但是要颠倒顺序，即令zj=x[i+1],z[j+1]=xi之后令 i=i+2,j=j+2。这个操作检查了 xi 和 x[i+1]。⑥截断：删掉 x 中剩下的全部字符，即令 i=m+1。这个操作检查了 x 中当前尚未被检查到的全部字符，这个操作只能作为最后一个操作出现在编辑操作序列中。 
例如将源串：algorithm 转换成目标串 altruistic 的一种方法是采用下面的操作序列：
操作               目标串              源串
copy a              a                  lgorithm
copy l              al                 gorithm
replace g by t      alt                orithm
delete o            alt                rithm
copy r              altr               ithm
insert u            altr               ithm
insert i            altrui             ithm
insert s            altruis            ithm
twiddle it into ti  altruisti          hm
insert c            altruistic         hm
kill                altruistic    

  上述每一个变换操作都有相应的代价。假定所有编辑操作的代价都是常数并且是已知的，且要求拷贝和替换操作的代价小于等效的删除、插入操作的代价的和。定义给定的编辑操作序列的代价是其中每一个编辑操作的代价的总和，对上面的例子来说，编辑序列的代价是（3*cost（copy））+cost（replace）+cost（delete）+（4*cost（insert）） +cost（twiddle）+cost（kill）。显然，需要找到一个从源串到  目标串的具有最小代价的编辑操作序列。 
（2）课程设计目的 
掌握动态规划方法，能够编程实现。对编辑距离建立一定的认识，并能将某些问题转化为编辑距离问题。 
（3）基本要求 
①实现问题描述中第一种编辑操作（三个操作）编辑距离计算的动态规划算法，并用测试用例验证算法。 
②将问题描述中第二种编辑操作中给出的六个操作都实现，并将其作为串ADT 的基本操作实现一个串 ADT。 
③针对问题描述中第二种编辑操作，设计动态规划算法实现其编辑距离的计算，即找到一个代价最小的编辑操作序列，其中各个操作的代价根据实际情况自己设定。 
④应用③获得的最小代价编辑操作序列实现从源串到目标串的自动编辑。
⑤针对问题描述中第二种编辑操作，自行设计可获得自动编辑操作序列（代价不用最小）的一个算法，将其结果编辑操作序列和③获得的最小代价编辑操作序列进行代价上的对比。 
⑥（选作）编辑距离问题是 DNA 序列对齐问题的泛化。可以有很多方式对齐 DNA 序列，以衡量它们的相似程度。有一种对齐方式是，可以在两个 DNA序列的任何位置（包括两头）插入空格，但是要求通过这个过程得到的序列 x1和 y1 长度相同，而且在两个序列的同一位置上不能都是空格。做到这一步之后我们为每一个位置分配一个“得分”，例如位置 j 按照如下规则得分：如果x1[j]==y1[j]，1 分；如果 x1[i]!=y1[j]并且两者都不是空格，-1 分；如果 x1[j]或者y1[j]是空格，-2 分。某种特定对齐结果的得分，是全部位置的得分的总和。例如对序列 x=GATCGGCAT 和 y=CAATGTGAATC，一个可能的对齐如下：
    GATCGGCAT
    CAATGTGAATC 
    -*++*+*+-++* 
    其中+对应 1 分，-对应-1 分，*对应-2 分。 
这个对齐的总分是-1-2+2-2+1-2+1-1+2-2=-1-2+1-2=-4。   
在上述编辑距离动态规划算法基础上，编写程序求出两个 DNA 序列的最优对齐，即得分最多的对齐。 
（4）实现提示 需要查阅关于动态规划算法的有关资料。
